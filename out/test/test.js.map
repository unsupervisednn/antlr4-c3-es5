{"version":3,"file":"test.js","sourceRoot":"","sources":["../../test/test.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2016, 2017 Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n\"use strict\";\n\nimport * as fs from \"fs\"\nimport * as path from \"path\"\n\nimport { expect, should, assert } from 'chai';\nimport { ExprParser } from \"./ExprParser\";\nimport { ExprLexer } from \"./ExprLexer\";\nimport { CPP14Parser } from \"./CPP14Parser\";\nimport { CPP14Lexer } from \"./CPP14Lexer\";\n\nimport * as c3 from \"../index\";\n\nimport {\n    ANTLRErrorListener, ANTLRInputStream, CommonTokenStream, ParserRuleContext, Token, Recognizer,\n    RecognitionException, CommonToken\n} from 'antlr4ts';\nimport { Override } from \"antlr4ts/Decorators\";\nimport { TerminalNode } from \"antlr4ts/tree/TerminalNode\";\n\n// Some helper functions + types to create certain setups.\n\nexport class ErrorListener implements ANTLRErrorListener<CommonToken> {\n    errorCount = 0;\n\n    @Override\n    syntaxError<T extends Token>(recognizer: Recognizer<T, any>, offendingSymbol: T | undefined, line: number,\n        charPositionInLine: number, msg: string, e: RecognitionException | undefined): void {\n        ++this.errorCount;\n    }\n};\n\nconst dummyNode = new TerminalNode(new CommonToken(-2, \"Dummy\", undefined, 0, 10, 20));\n\n/**\n * Creates a single symbol table setup with a simple base structure:\n *   - [0] classes with [1] methods and [2] fields\n *   - two blocks in each method and 1 variable in each block.\n * In addition to that some global symbols are added ([3] variables, [4] literals).\n * If namespaces are given then the classes are distributed among them in a round-robin fashion.\n */\nfunction createClassSymbolTable(name: string, counts: number[], namespaces?: string[]): c3.SymbolTable {\n    let symbolTable = new c3.SymbolTable(name, { allowDuplicateSymbols: false });\n\n    let nsSymbols: (c3.NamespaceSymbol | undefined)[] = [undefined];\n    let nsIndex = 0;\n    let nsCount = 1;\n    if (namespaces && namespaces.length > 0) {\n        nsCount = namespaces.length;\n        for (let i = 0; i < nsCount; ++i) {\n            nsSymbols[i] = symbolTable.addNewNamespaceFromPath(undefined, namespaces[i]);\n        }\n    }\n\n    for (let i = 0; i < counts[0]; ++i) {\n        let classSymbol = symbolTable.addNewSymbolOfType(c3.ClassSymbol, nsSymbols[nsIndex], \"class\" + i);\n\n        for (let j = 0; j < counts[2]; ++j) {\n            let field = symbolTable.addNewSymbolOfType(c3.FieldSymbol, classSymbol, \"field\" + j);\n        }\n\n        for (let j = 0; j < counts[1]; ++j) {\n            let method = symbolTable.addNewSymbolOfType(c3.MethodSymbol, classSymbol, \"method\" + j);\n\n            // Blocks are created and added in an alternative way.\n            let block1 = symbolTable.addNewSymbolOfType(c3.BlockSymbol, undefined, \"block1\"); // Block at top level.\n            symbolTable.addNewSymbolOfType(c3.VariableSymbol, block1, \"var1\", 17, c3.FundamentalType.integerType);\n            let block2 = symbolTable.addNewSymbolOfType(c3.BlockSymbol, undefined, \"block2\");\n            let symbol = symbolTable.addNewSymbolOfType(c3.VariableSymbol, block2, \"var1\", 3.142, c3.FundamentalType.floatType);\n            if (j == 1) {\n                symbol.context = dummyNode;\n            }\n\n            // Now move the blocks from global level to the method.\n            method.addSymbol(block1);\n            method.addSymbol(block2);\n        }\n\n        ++nsIndex;\n        if (nsIndex == nsCount)\n            nsIndex = 0;\n    }\n\n    for (let i = 0; i < counts[3]; ++i) {\n        symbolTable.addNewSymbolOfType(c3.VariableSymbol, undefined, \"globalVar\" + i, 42, c3.FundamentalType.integerType);\n    }\n\n    for (let i = 0; i < counts[4]; ++i) {\n        symbolTable.addNewSymbolOfType(c3.LiteralSymbol, undefined, \"globalConst\" + i, \"string constant\", c3.FundamentalType.stringType);\n    }\n\n    return symbolTable;\n}\n\n// Begin of the tests.\ndescribe('antlr4-c3:', function () {\n    this.slow(1000);\n\n    describe('Symbol table tests:', function () {\n        it(\"Single table base tests\", function () {\n            let symbolTable = createClassSymbolTable(\"main\", [3, 3, 4, 5, 5]);\n            let info = symbolTable.info;\n            expect(info.dependencyCount, \"Test 1\").to.equal(0);\n            expect(info.symbolCount, \"Test 2\").to.equal(13); // 5 + 5 top level symbols + 3 classes.\n\n            try {\n                symbolTable.addNewSymbolOfType(c3.VariableSymbol, undefined, \"globalVar3\");\n                assert(false);\n            } catch (e) {\n                if (e instanceof c3.DuplicateSymbolError) {\n                    expect(e.message, \"Test 3\").to.equal(\"Attempt to add duplicate symbol 'globalVar3'\");\n                } else {\n                    assert(false, \"Test 3\");\n                }\n            }\n\n            let class1 = symbolTable.resolve(\"class1\");\n            expect(class1, \"Test 4\").is.instanceof(c3.ClassSymbol);\n            let method2 = (class1 as c3.ClassSymbol).resolve(\"method2\");\n            expect(method2, \"Test 5\").is.instanceof(c3.MethodSymbol);\n            let scopes = (method2 as c3.MethodSymbol).directScopes;\n            expect(scopes.length, \"Test 6\").equals(2); // 2 anonymous blocks.\n            expect(scopes[0], \"Test 7\").is.instanceof(c3.ScopedSymbol);\n\n            let block1 = scopes[0] as c3.ScopedSymbol;\n            try {\n                let duplicateMethod = symbolTable.addNewSymbolOfType(c3.MethodSymbol, undefined, \"method2\");\n                (class1 as c3.ClassSymbol).addSymbol(duplicateMethod); // Must throw.\n                assert(false);\n            } catch (e) {\n                if (e instanceof c3.DuplicateSymbolError) {\n                    expect(e.message, \"Test 8\").to.equal(\"Attempt to add duplicate symbol 'method2'\");\n                } else {\n                    assert(false);\n                }\n            }\n\n            let variable = scopes[0].resolve(\"globalVar3\"); // Resolves to the global var 3.\n            expect(variable, \"Test 9\").to.be.instanceof(c3.VariableSymbol);\n            expect(variable!.root, \"Test 10\").to.equal(symbolTable);\n\n            variable = scopes[0].resolve(\"globalVar3\", true); // Try only local vars.\n            expect(variable, \"Test 11\").to.equal(undefined);\n\n            variable = scopes[0].resolve(\"var1\"); // Now resolves to local var.\n            expect(variable!.root, \"Test 12\").to.equal(class1);\n            expect(variable!.getParentOfType(c3.MethodSymbol), \"Test 13\").to.equal(method2);\n            expect((class1 as c3.ClassSymbol).getSymbolsOfType(c3.MethodSymbol).length, \"Test 14\").to.equal(3);\n            expect((method2 as c3.MethodSymbol).getSymbolsOfType(c3.ScopedSymbol).length, \"Test 15\").to.equal(2);\n            expect(block1.resolve(\"class1\", false), \"Test 16\").to.equal(class1);\n\n            let path = variable!.symbolPath;\n            expect(path.length, \"Test 17\").to.equal(5);\n            expect(path[0].name, \"Test 18\").to.equal(\"var1\");\n            expect(path[1].name, \"Test 19\").to.equal(\"block1\");\n            expect(path[2].name, \"Test 20\").to.equal(\"method2\");\n            expect(path[3].name, \"Test 21\").to.equal(\"class1\");\n            expect(path[4].name, \"Test 22\").to.equal(\"main\");\n\n            expect(method2!.qualifiedName(), \"Test 23\").to.equal(\"class1.method2\");\n            expect(method2!.qualifiedName(\"-\", true), \"Test 24\").to.equal(\"main-class1-method2\");\n            expect(variable!.qualifiedName(), \"Test 25\").to.equal(\"block1.var1\");\n            expect(variable!.qualifiedName(\"#\"), \"Test 26\").to.equal(\"block1#var1\");\n            expect(variable!.qualifiedName(\".\", false, true), \"Test 27\").to.equal(\"block1.var1\");\n            expect(variable!.qualifiedName(\".\", true, false), \"Test 28\").to.equal(\"main.class1.method2.block1.var1\");\n            expect(variable!.qualifiedName(\".\", true, true), \"Test 29\").to.equal(\"main.class1.method2.block1.var1\");\n\n            let allSymbols = symbolTable.getAllNestedSymbols();\n            expect(allSymbols.length, \"Test 30\").to.equal(70);\n\n            let symbolPath = allSymbols[59].qualifiedName(\".\", true);\n            expect(symbolPath, \"Test 31\").to.equal(\"main.class2.method2.block2.var1\");\n            expect(symbolTable.symbolFromPath(\"main.class2.method2.block2.var1\"), \"Test 32\").to.equal(allSymbols[59]);\n\n            expect(symbolTable, \"Test 33\").to.equal(symbolTable.symbolTable);\n        });\n\n        it(\"Single table type checks\", function () {\n            // Create a symbol table with all the symbols we have in the lib and query it for some collections.\n            // Start with a standard table containing a class with a single method, a global var and a global literal symbol.\n            // Hierarchy is not really important here.\n            let symbolTable = createClassSymbolTable(\"main\", [1, 1, 1, 1, 1]);\n\n            // Now add all the other symbols.\n            let alias = symbolTable.addNewSymbolOfType(c3.TypeAlias, undefined, \"newBool\", c3.FundamentalType.boolType);\n            let routine = symbolTable.addNewSymbolOfType(c3.RoutineSymbol, undefined, \"routine1\", c3.FundamentalType.integerType);\n            let field = symbolTable.addNewSymbolOfType(c3.FieldSymbol, undefined, \"field1\", c3.FundamentalType.floatType);\n\n        });\n\n        it(\"Single table stress test\", function () {\n            let symbolTable = createClassSymbolTable(\"table\", [300, 30, 20, 1000, 1000]);\n            expect(symbolTable.getAllNestedSymbols().length, \"Test 1\").to.equal(53300);\n            expect(symbolTable.getNestedSymbolsOfType(c3.ClassSymbol).length, \"Test 2\").to.equal(300);\n            expect(symbolTable.getNestedSymbolsOfType(c3.MethodSymbol).length, \"Test 3\").to.equal(9000);\n            expect(symbolTable.getNestedSymbolsOfType(c3.ScopedSymbol).length, \"Test 4\").to.equal(27300);\n            expect(symbolTable.getNestedSymbolsOfType(c3.VariableSymbol).length, \"Test 5\").to.equal(25000); // Includes class fields.\n            expect(symbolTable.getNestedSymbolsOfType(c3.FieldSymbol).length, \"Test 6\").to.equal(6000);\n            expect(symbolTable.getNestedSymbolsOfType(c3.LiteralSymbol).length, \"Test 7\").to.equal(1000);\n        }).timeout(20000);\n\n        it(\"Single table namespace tests\", function () {\n            let symbolTable = createClassSymbolTable(\"main\", [30, 10, 10, 100, 100], [\"ns1\", \"ns2\", \"ns1.ns3.ns5\", \"ns1.ns4.ns6.ns8\"]);\n\n            let namespaces = symbolTable.getNestedSymbolsOfType(c3.NamespaceSymbol);\n            expect(namespaces.length, \"Test 1\").to.equal(7);\n\n            // This call does a depth-first search, so all the deeper nested namespaces appear at the lower indexes\n            // and the less nested ones at the end of the list.\n            let methods = symbolTable.getNestedSymbolsOfType(c3.MethodSymbol);\n            expect(methods.length, \"Test 2\").to.equal(300);\n            expect(methods[2].qualifiedName(\".\", true), \"Test 3\").to.equal(\"main.ns1.ns3.ns5.class2.method2\");\n            expect(methods[299].qualifiedName(\".\", true), \"Test 4\").to.equal(\"main.ns2.class29.method9\");\n        });\n\n        it(\"Multi table tests\", function () {\n            // Interactions between linked symbol tables. We use 5 tables here:\n            // - the main table as in the single table tests.\n            // - a system functions table\n            // - a table with variables, which has 2 other dependencies (functions in same namespace as system\n            //   functions and one in a different namespace)\n            let main = createClassSymbolTable(\"main\", [30, 10, 10, 100, 100]);\n            let systemFunctions = new c3.SymbolTable(\"system functions\", { allowDuplicateSymbols: false });\n            let namespace1 = systemFunctions.addNewSymbolOfType(c3.NamespaceSymbol, undefined, \"ns1\");\n            for (let i = 0; i < 333; ++i) {\n                systemFunctions.addNewSymbolOfType(c3.RoutineSymbol, namespace1, \"func\" + i);\n            }\n            main.addDependencies(systemFunctions);\n\n            let libFunctions = new c3.SymbolTable(\"library functions\", { allowDuplicateSymbols: false });\n            let namespace2 = libFunctions.addNewSymbolOfType(c3.NamespaceSymbol, undefined, \"ns2\");\n            for (let i = 0; i < 444; ++i) {\n                // Same names as in the system functions but different namespace.\n                libFunctions.addNewSymbolOfType(c3.RoutineSymbol, namespace2, \"func\" + i);\n            }\n\n            let libVariables = new c3.SymbolTable(\"library variables\", { allowDuplicateSymbols: false });\n\n            // Like for the system functions.\n            let namespace3 = libVariables.addNewSymbolOfType(c3.NamespaceSymbol, undefined, \"ns1\");\n            for (let i = 0; i < 555; ++i) {\n                libVariables.addNewSymbolOfType(c3.VariableSymbol, namespace3, \"var\" + i);\n            }\n\n            let libFunctions2 = new c3.SymbolTable(\"library functions 2\", { allowDuplicateSymbols: false });\n            let namespace4 = libFunctions2.addNewSymbolOfType(c3.NamespaceSymbol, undefined, \"ns1\");\n            for (let i = 0; i < 666; ++i) {\n                // Same names as in the system functions but different namespace.\n                libFunctions2.addNewSymbolOfType(c3.RoutineSymbol, namespace4, \"func\" + i);\n            }\n\n            libVariables.addDependencies(libFunctions, libFunctions2);\n            main.addDependencies(systemFunctions, libVariables);\n\n            // Note: namespaces are handled in the context of their parent.\n            // Symbols in a namespace/module/library are accessible from their parent.\n            expect(main.getAllSymbols().size, \"Test 1\").to.equal(2232);\n            expect(systemFunctions.getAllSymbols().size, \"Test 2\").to.equal(334); // System functions alone + the namespace.\n            expect(libFunctions.getAllSymbols().size, \"Test 3\").to.equal(445); // Lib functions alone + the namespace.\n            expect(libVariables.getAllSymbols().size, \"Test 4\").to.equal(1668); // Lib variables + lib functions + namespaces.\n            expect(libFunctions2.getAllSymbols().size, \"Test 5\").to.equal(667); // Lib functions in \"ns1\" only + the namespace.\n        });\n\n        it(\"Symbol navigation\", function() {\n            let symbolTable = createClassSymbolTable(\"main\", [10, 10, 10, 20, 34], []);\n\n            let namespaces = symbolTable.getNestedSymbolsOfType(c3.NamespaceSymbol);\n            expect(namespaces.length, \"Test 1\").to.equal(0);\n\n            let variables = symbolTable.getNestedSymbolsOfType(c3.VariableSymbol);\n            expect(variables.length, \"Test 2\").to.equal(320);\n\n            // A class member.\n            let field7 = variables[217];\n            expect(field7, \"Test 3\").not.to.be.undefined;\n            expect(field7.firstSibling, \"Test 4\").to.equal(variables[210]);\n            expect(field7.lastSibling.name, \"Test 5\").to.equal(\"method9\");\n            expect(field7.previousSibling, \"Test 6\").to.equal(variables[216]);\n            expect(field7.nextSibling, \"Test 7\").to.equal(variables[218]);\n\n            expect(field7.firstSibling.firstSibling.firstSibling.firstSibling, \"Test 8\").to.equal(field7.firstSibling);\n            expect(field7.lastSibling.lastSibling.lastSibling.lastSibling, \"Test 9\").to.equal(field7.lastSibling);\n            expect(field7.firstSibling.lastSibling.firstSibling.firstSibling, \"Test 10\").to.equal(field7.firstSibling);\n            expect(field7.lastSibling.firstSibling.firstSibling.lastSibling, \"Test 11\").to.equal(field7.lastSibling);\n\n            expect(field7.parent, \"Test 12\").to.be.instanceof(c3.ClassSymbol);\n\n            let parent7 = field7.parent as c3.ClassSymbol;\n            expect(parent7.indexOfChild(field7), \"Test 13\").to.equal(7);\n            expect(parent7.firstChild, \"Test 14\").to.equal(field7.firstSibling);\n            expect(parent7.lastChild, \"Test 15\").to.equal(field7.lastSibling);\n\n            // A local variable (a single one in a block).\n            let var1 = variables[286];\n            expect(var1, \"Test 16\").not.to.be.undefined;\n            expect(var1.firstSibling, \"Test 17\").to.equal(var1);\n            expect(var1.lastSibling.name, \"Test 18\").to.equal(\"var1\");\n            expect(var1.previousSibling, \"Test 19\").to.be.undefined;\n            expect(var1.nextSibling, \"Test 20\").to.undefined;\n\n            expect(var1.firstSibling.firstSibling.firstSibling.firstSibling, \"Test 21\").to.equal(var1.firstSibling);\n            expect(var1.lastSibling.lastSibling.lastSibling.lastSibling, \"Test 22\").to.equal(var1.lastSibling);\n            expect(var1.firstSibling.lastSibling.firstSibling.firstSibling, \"Test 23\").to.equal(var1.firstSibling);\n            expect(var1.lastSibling.firstSibling.firstSibling.lastSibling, \"Test 24\").to.equal(var1.lastSibling);\n\n            let block1 = var1.parent as c3.ScopedSymbol;\n            expect(block1.indexOfChild(field7), \"Test 25\").to.equal(-1);\n            expect(block1.indexOfChild(var1), \"Test 26\").to.equal(0);\n            expect(block1.firstChild, \"Test 27\").to.equal(var1.firstSibling);\n            expect(block1.lastChild, \"Test 28\").to.equal(var1.lastSibling);\n\n            // A global variable (a single one in a block).\n            let var15 = variables[315];\n            expect(var15, \"Test 29\").not.to.be.undefined;\n            expect(var15.firstSibling, \"Test 30\").to.equal(symbolTable.firstChild);\n            expect(var15.lastSibling.name, \"Test 31\").to.equal(\"globalConst33\");\n            expect(var15.previousSibling, \"Test 32\").to.equal(variables[314]);\n            expect(var15.nextSibling, \"Test 33\").to.equal(variables[316]);\n\n            expect(var15.parent, \"Test 34\").to.be.instanceof(c3.SymbolTable);\n\n            let st1 = var15.parent as c3.ScopedSymbol;\n            expect(st1.indexOfChild(var15), \"Test 35\").to.equal(25);\n            expect(st1.firstChild, \"Test 36\").to.equal(var15.firstSibling);\n            expect(st1.lastChild, \"Test 37\").to.equal(var15.lastSibling);\n\n            let next = variables[284].next;\n            expect(next, \"Test 38\").not.to.be.undefined;\n            expect(next!.qualifiedName(\".\", true), \"Test 39\").to.equal(\"main.class9.method2.block1.var1\");\n\n            let symbol = symbolTable.symbolWithContext(dummyNode);\n            expect(symbol, \"Test 40\").not.to.be.undefined;\n            expect(symbol!.qualifiedName(\".\", true), \"Test 41\").to.equal(\"main.class0.method1.block2.var1\");\n        });\n    });\n\n    describe('Simple expression parser:', function () {\n        it(\"Most simple setup\", function () {\n            // No customization happens here, so the c3 engine only returns lexer tokens.\n            let inputStream = new ANTLRInputStream(\"var c = a + b()\");\n            let lexer = new ExprLexer(inputStream);\n            let tokenStream = new CommonTokenStream(lexer);\n\n            let parser = new ExprParser(tokenStream);\n            let errorListener = new ErrorListener();\n            parser.addErrorListener(errorListener);\n            let tree = parser.expression();\n            expect(errorListener.errorCount, \"Test 1\").equals(0);\n\n            let core = new c3.CodeCompletionCore(parser);\n\n            // 1) At the input start.\n            let candidates = core.collectCandidates(0);\n\n            expect(candidates.tokens.size, \"Test 2\").to.equal(3);\n            expect(candidates.tokens.has(ExprLexer.VAR), \"Test 3\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.LET), \"Test 4\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.ID), \"Test 5\").to.equal(true);\n\n            expect(candidates.tokens.get(ExprLexer.VAR), \"Test 6\").to.eql([ExprLexer.ID, ExprLexer.EQUAL]);\n            expect(candidates.tokens.get(ExprLexer.LET), \"Test 7\").to.eql([ExprLexer.ID, ExprLexer.EQUAL]);\n            expect(candidates.tokens.get(ExprLexer.ID), \"Test 8\").to.eql([]);\n\n            // 2) On the first whitespace. In real implementations you would do some additional checks where in the whitespace\n            //    the caret is, as the outcome is different depending on that position.\n            candidates = core.collectCandidates(1);\n            expect(candidates.tokens.size, \"Test 9\").to.equal(1);\n            expect(candidates.tokens.has(ExprLexer.ID), \"Test 10\").to.equal(true);\n\n            // 3) On the variable name ('c').\n            candidates = core.collectCandidates(2);\n            expect(candidates.tokens.size, \"Test 11\").to.equal(1);\n            expect(candidates.tokens.has(ExprLexer.ID), \"Test 12\").to.equal(true);\n\n            // 4) On the equal sign (ignoring whitespace positions from now on).\n            candidates = core.collectCandidates(4);\n            expect(candidates.tokens.size, \"Test 13\").to.equal(1);\n            expect(candidates.tokens.has(ExprLexer.EQUAL), \"Test 14\").to.equal(true);\n\n            // 5) On the variable reference 'a'. But since we have not configure the c3 engine to return us var refs\n            //    (or function refs for that matter) we only get an ID here.\n            candidates = core.collectCandidates(6);\n            expect(candidates.tokens.size, \"Test 15\").to.equal(1);\n            expect(candidates.tokens.has(ExprLexer.ID), \"Test 16\").to.equal(true);\n\n            // 6) On the '+' operator. Usually you would not show operators as candidates, but we have not set up the c3 engine\n            //    yet to not return them.\n            candidates = core.collectCandidates(8);\n            expect(candidates.tokens.size, \"Test 17\").to.equal(5);\n            expect(candidates.tokens.has(ExprLexer.PLUS), \"Test 18\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.MINUS), \"Test 19\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.MULTIPLY), \"Test 20\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.DIVIDE), \"Test 21\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.OPEN_PAR), \"Test 22\").to.equal(true);\n        });\n\n        it(\"Typical setup\", function () {\n            let inputStream = new ANTLRInputStream(\"var c = a + b\");\n            let lexer = new ExprLexer(inputStream);\n            let tokenStream = new CommonTokenStream(lexer);\n\n            let parser = new ExprParser(tokenStream);\n            let errorListener = new ErrorListener();\n            parser.addErrorListener(errorListener);\n            let tree = parser.expression();\n            expect(errorListener.errorCount, \"Test 1\").equals(0);\n\n            let core = new c3.CodeCompletionCore(parser);\n\n            // Ignore operators and the generic ID token.\n            core.ignoredTokens = new Set([ExprLexer.ID, ExprLexer.PLUS, ExprLexer.MINUS, ExprLexer.MULTIPLY, ExprLexer.DIVIDE, ExprLexer.EQUAL]);\n\n            // Tell the engine to return certain rules to us, which we could use to look up values in a symbol table.\n            core.preferredRules = new Set([ExprParser.RULE_functionRef, ExprParser.RULE_variableRef]);\n\n            // 1) At the input start.\n            let candidates = core.collectCandidates(0);\n\n            expect(candidates.tokens.size, \"Test 2\").to.equal(2);\n            expect(candidates.tokens.has(ExprLexer.VAR), \"Test 3\").to.equal(true);\n            expect(candidates.tokens.has(ExprLexer.LET), \"Test 4\").to.equal(true);\n\n            expect(candidates.tokens.get(ExprLexer.VAR), \"Test 5\").to.eql([ExprLexer.ID, ExprLexer.EQUAL]);\n            expect(candidates.tokens.get(ExprLexer.LET), \"Test 6\").to.eql([ExprLexer.ID, ExprLexer.EQUAL]);\n\n            // 2) On the variable name ('c').\n            candidates = core.collectCandidates(2);\n            expect(candidates.tokens.size, \"Test 7\").to.equal(0);\n\n            // 4) On the equal sign.\n            candidates = core.collectCandidates(4);\n            expect(candidates.tokens.size, \"Test 8\").to.equal(0);\n\n            // 5) On the variable reference 'a'.\n            candidates = core.collectCandidates(6);\n            expect(candidates.tokens.size, \"Test 9\").to.equal(0);\n            expect(candidates.rules.size, \"Test 10\").to.equal(2);\n\n            // Here we get 2 rule indexes, derived from 2 different IDs possible at this caret position.\n            // These are what we told the engine above to be preferred rules for us.\n            let found = 0;\n            for (let candidate of candidates.rules) {\n                switch (candidate[0]) {\n                    case ExprParser.RULE_functionRef: {\n                        ++found\n                        break;\n                    }\n\n                    case ExprParser.RULE_variableRef: {\n                        ++found;\n                        break;\n                    }\n\n                    default:\n                        assert(false);\n                }\n            }\n            expect(found, \"Test 11\").to.equal(2);\n\n            // 6) On the whitespace just after the variable reference 'a' (but it could still be a function reference!)\n            candidates = core.collectCandidates(7);\n            expect(candidates.tokens.size, \"Test 11\").to.equal(0);\n            expect(candidates.rules.size, \"Test 12\").to.equal(1);\n        });\n    });\n\n    describe('C++14 parser:', function () {\n        it('Simple C++ example', function () {\n            // We are trying here to get useful code completion candidates without adjusting the grammar in any way.\n            // We use the grammar as downloaded from the ANTLR grammar directory and set up the c3 engine\n            // instead in a way that still returns useful info. This limits us somewhat.\n            let inputStream = new ANTLRInputStream(\"class A {\\n\" +\n                \"public:\\n\" +\n                \"  void test() {\\n\" +\n                \"  }\\n\" +\n                \"};\\n\"\n            );\n            let lexer = new CPP14Lexer(inputStream);\n            let tokenStream = new CommonTokenStream(lexer);\n\n            /*\n            tokenStream.fill();\n            for (let token of tokenStream.getTokens())\n              console.log(token.toString());\n            */\n\n            let parser = new CPP14Parser(tokenStream);\n            let errorListener = new ErrorListener();\n            parser.addErrorListener(errorListener);\n            let tree = parser.translationunit();\n            expect(errorListener.errorCount, \"Test 1\").equals(0);\n\n            let core = new c3.CodeCompletionCore(parser);\n\n            // Ignore operators and the generic ID token.\n            core.ignoredTokens = new Set([\n                CPP14Lexer.Identifier,\n                CPP14Lexer.LeftParen, CPP14Lexer.RightParen,\n                CPP14Lexer.Operator, CPP14Lexer.Star, CPP14Lexer.And, CPP14Lexer.AndAnd,\n                CPP14Lexer.LeftBracket,\n                CPP14Lexer.Ellipsis,\n                CPP14Lexer.Doublecolon, CPP14Lexer.Semi,\n            ]);\n\n            // For a C++ grammar you can of course get many candidates of all kind. For this test we focus only on a few,\n            // namely namespace, class and variable references. For variable references there is no own rule, only an\n            // \"idexpression\" as part of the primary expression.\n            core.preferredRules = new Set([CPP14Parser.RULE_classname, CPP14Parser.RULE_namespacename, CPP14Parser.RULE_idexpression]);\n\n            // 1) At the input start.\n            let candidates = core.collectCandidates(0);\n\n            expect(candidates.tokens.size, \"Test 2\").to.equal(40);\n            expect(candidates.tokens.has(CPP14Lexer.Extern), \"Test 3\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Mutable), \"Test 4\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Register), \"Test 5\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Static), \"Test 6\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Thread_local), \"Test 7\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Decltype), \"Test 8\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Char), \"Test 9\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Char16), \"Test 10\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Char32), \"Test 11\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Wchar), \"Test 12\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Bool), \"Test 13\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Short), \"Test 14\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Int), \"Test 15\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Long), \"Test 16\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Signed), \"Test 17\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Unsigned), \"Test 18\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Float), \"Test 19\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Double), \"Test 20\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Void), \"Test 21\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Auto), \"Test 22\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Class), \"Test 23\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Struct), \"Test 24\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Union), \"Test 25\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Enum), \"Test 26\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Typename), \"Test 27\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Const), \"Test 28\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Volatile), \"Test 29\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Explicit), \"Test 30\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Inline), \"Test 31\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Virtual), \"Test 32\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Friend), \"Test 33\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Typedef), \"Test 34\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Constexpr), \"Test 35\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Alignas), \"Test 36\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Asm), \"Test 37\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Namespace), \"Test 38\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Using), \"Test 39\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Static_assert), \"Test 40\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Template), \"Test 41\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.EOF), \"Test 42\").to.equal(true);\n\n            expect(candidates.tokens.has(CPP14Lexer.Identifier), \"Test 43\").to.equal(false);\n\n            // The returned list can contain more than one entry for a particular rule, if there are multiple\n            // parser rule paths leading to it.\n            expect(candidates.rules.size, \"Test 44\").to.equal(3);\n            expect(candidates.rules.get(CPP14Parser.RULE_namespacename), \"Test 45\").to.eql([\n                CPP14Parser.RULE_translationunit,\n                CPP14Parser.RULE_declarationseq,\n                CPP14Parser.RULE_declaration,\n                CPP14Parser.RULE_blockdeclaration,\n                CPP14Parser.RULE_simpledeclaration,\n                CPP14Parser.RULE_declspecifierseq,\n                CPP14Parser.RULE_declspecifier,\n                CPP14Parser.RULE_typespecifier,\n                CPP14Parser.RULE_trailingtypespecifier,\n                CPP14Parser.RULE_simpletypespecifier,\n                CPP14Parser.RULE_nestednamespecifier,\n            ]);\n            expect(candidates.rules.get(CPP14Parser.RULE_classname), \"Test 46\").to.eql([\n                CPP14Parser.RULE_translationunit,\n                CPP14Parser.RULE_declarationseq,\n                CPP14Parser.RULE_declaration,\n                CPP14Parser.RULE_blockdeclaration,\n                CPP14Parser.RULE_simpledeclaration,\n                CPP14Parser.RULE_declspecifierseq,\n                CPP14Parser.RULE_declspecifier,\n                CPP14Parser.RULE_typespecifier,\n                CPP14Parser.RULE_trailingtypespecifier,\n                CPP14Parser.RULE_simpletypespecifier,\n                CPP14Parser.RULE_nestednamespecifier,\n                CPP14Parser.RULE_typename,\n            ]);\n\n            // 2) Within the method body.\n            //    Note when counting token indexes: the C++14 grammar skips all whitespaces, hence there are no tokens for them.\n            candidates = core.collectCandidates(10);\n\n            expect(candidates.rules.size, \"Test 47\").to.equal(1);\n            expect(candidates.rules.get(CPP14Parser.RULE_idexpression), \"Test 48\").to.eql([\n                CPP14Parser.RULE_translationunit,\n                CPP14Parser.RULE_declarationseq,\n                CPP14Parser.RULE_declaration,\n                CPP14Parser.RULE_functiondefinition,\n                CPP14Parser.RULE_declspecifierseq,\n                CPP14Parser.RULE_declspecifier,\n                CPP14Parser.RULE_typespecifier,\n                CPP14Parser.RULE_classspecifier,\n                CPP14Parser.RULE_memberspecification,\n                CPP14Parser.RULE_memberspecification,\n                CPP14Parser.RULE_memberdeclaration,\n\n                CPP14Parser.RULE_memberdeclaratorlist,\n                CPP14Parser.RULE_memberdeclarator,\n                CPP14Parser.RULE_braceorequalinitializer,\n                CPP14Parser.RULE_bracedinitlist,\n                CPP14Parser.RULE_initializerlist,\n                CPP14Parser.RULE_initializerclause,\n\n                CPP14Parser.RULE_assignmentexpression,\n                CPP14Parser.RULE_conditionalexpression,\n                CPP14Parser.RULE_logicalorexpression,\n                CPP14Parser.RULE_logicalandexpression,\n                CPP14Parser.RULE_inclusiveorexpression,\n                CPP14Parser.RULE_exclusiveorexpression,\n                CPP14Parser.RULE_andexpression,\n                CPP14Parser.RULE_equalityexpression,\n                CPP14Parser.RULE_relationalexpression,\n                CPP14Parser.RULE_shiftexpression,\n                CPP14Parser.RULE_additiveexpression,\n                CPP14Parser.RULE_multiplicativeexpression,\n                CPP14Parser.RULE_pmexpression,\n                CPP14Parser.RULE_castexpression,\n                CPP14Parser.RULE_unaryexpression,\n                CPP14Parser.RULE_postfixexpression,\n                CPP14Parser.RULE_primaryexpression,\n            ]);\n\n            // We are starting a primary expression in a function body, so everything related to expressions and control flow is allowed here.\n            // We only check for a few possible keywords.\n            expect(candidates.tokens.size, \"Test 49\").to.equal(81);\n            expect(candidates.tokens.has(CPP14Lexer.If), \"Test 50\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.This), \"Test 51\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.New), \"Test 52\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Case), \"Test 53\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.While), \"Test 54\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Throw), \"Test 55\").to.equal(true);\n\n            expect(candidates.tokens.has(CPP14Lexer.Override), \"Test 56\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Export), \"Test 57\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Private), \"Test 58\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Protected), \"Test 59\").to.equal(false);\n        }).timeout(5000);\n\n        it('Simple C++ example with errors in input', function () {\n            let inputStream = new ANTLRInputStream(\"class A {\\n\" +\n                \"public:\\n\" +\n                \"  void test() {\\n\" +\n                \"    if ()\" +\n                \"  }\\n\" +\n                \"};\\n\"\n            );\n            let lexer = new CPP14Lexer(inputStream);\n            let tokenStream = new CommonTokenStream(lexer);\n\n            let parser = new CPP14Parser(tokenStream);\n            parser.removeErrorListeners();\n            let errorListener = new ErrorListener();\n            parser.addErrorListener(errorListener);\n            let tree = parser.translationunit();\n            expect(errorListener.errorCount, \"Test 1\").equals(3);\n\n            let core = new c3.CodeCompletionCore(parser);\n\n            // Ignore operators and the generic ID token.\n            core.ignoredTokens = new Set([\n                CPP14Lexer.Identifier,\n                //CPP14Lexer.LeftParen, CPP14Lexer.RightParen, Let parentheses show up in this test\n                CPP14Lexer.Operator, CPP14Lexer.Star, CPP14Lexer.And, CPP14Lexer.AndAnd,\n                CPP14Lexer.LeftBracket,\n                CPP14Lexer.Ellipsis,\n                CPP14Lexer.Doublecolon, CPP14Lexer.Semi,\n            ]);\n\n            core.preferredRules = new Set([CPP14Parser.RULE_classname, CPP14Parser.RULE_namespacename, CPP14Parser.RULE_idexpression]);\n\n            core.showDebugOutput = false;\n            core.showRuleStack = false;\n            let candidates = core.collectCandidates(11); // At the opening parenthesis.\n\n            expect(candidates.tokens.size, \"Test 2\").to.equal(1);\n            expect(candidates.tokens.has(CPP14Lexer.LeftParen), \"Test 3\").to.equal(true);\n\n            candidates = core.collectCandidates(12); // At the closing parenthesis -> again everything in an expression allowed (no control flow this time, tho).\n\n            expect(candidates.tokens.size, \"Test 4\").to.equal(64);\n            expect(candidates.tokens.has(CPP14Lexer.If), \"Test 5\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.This), \"Test 6\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.New), \"Test 7\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Case), \"Test 8\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.While), \"Test 9\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Throw), \"Test 10\").to.equal(true);\n\n            expect(candidates.tokens.has(CPP14Lexer.Override), \"Test 11\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Export), \"Test 12\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Private), \"Test 13\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Protected), \"Test 14\").to.equal(false);\n\n            candidates = core.collectCandidates(13); // After the error position -> no suggestions.\n            expect(candidates.tokens.size, \"Test 15\").to.equal(0);\n            expect(candidates.rules.size, \"Test 16\").to.equal(0);\n        });\n\n        it('Real C++ file', function () {\n            this.slow(10000);\n\n            let source = fs.readFileSync(path.join(__dirname, \"../../test/Parser.cpp\")).toString();\n            let inputStream = new ANTLRInputStream(source);\n            let lexer = new CPP14Lexer(inputStream);\n            let tokenStream = new CommonTokenStream(lexer);\n\n            /*\n            tokenStream.fill();\n            for (let token of tokenStream.getTokens())\n              console.log(token.toString());\n            */\n\n            let parser = new CPP14Parser(tokenStream);\n            let errorListener = new ErrorListener();\n            parser.addErrorListener(errorListener);\n            let tree = parser.translationunit();\n            expect(errorListener.errorCount, \"Test 1\").equals(0);\n\n            let core = new c3.CodeCompletionCore(parser);\n\n            // Ignore operators and the generic ID token.\n            core.ignoredTokens = new Set([\n                CPP14Lexer.Identifier,\n                CPP14Lexer.LeftParen, CPP14Lexer.RightParen,\n                CPP14Lexer.Operator, CPP14Lexer.Star, CPP14Lexer.And, CPP14Lexer.AndAnd,\n                CPP14Lexer.LeftBracket,\n                CPP14Lexer.Ellipsis,\n                CPP14Lexer.Doublecolon, CPP14Lexer.Semi,\n            ]);\n\n            core.preferredRules = new Set([CPP14Parser.RULE_classname, CPP14Parser.RULE_namespacename, CPP14Parser.RULE_idexpression]);\n\n            let candidates = core.collectCandidates(3469);\n\n            expect(candidates.rules.size, \"Test 47\").to.equal(1);\n\n            // We are starting a primary expression in a function body, so everything related to expressions and control flow is allowed here.\n            // We only check for a few possible keywords.\n            expect(candidates.tokens.size, \"Test 49\").to.equal(81);\n            expect(candidates.tokens.has(CPP14Lexer.If), \"Test 50\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.This), \"Test 51\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.New), \"Test 52\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Case), \"Test 53\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.While), \"Test 54\").to.equal(true);\n            expect(candidates.tokens.has(CPP14Lexer.Throw), \"Test 55\").to.equal(true);\n\n            expect(candidates.tokens.has(CPP14Lexer.Override), \"Test 56\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Export), \"Test 57\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Private), \"Test 58\").to.equal(false);\n            expect(candidates.tokens.has(CPP14Lexer.Protected), \"Test 59\").to.equal(false);\n        }).timeout(60000);\n    });\n\n\n});\n"]}