{"version":3,"file":"SymbolTable.js","sourceRoot":"","sources":["../../src/SymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2017, 2019, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n'use strict';\n\nimport { ParseTree } from 'antlr4ts/tree/ParseTree';\n\nexport class DuplicateSymbolError extends Error { };\n\nexport enum MemberVisibility {\n    Invalid = -1,\n    Public = 0,\n    Protected,\n    Private,\n    Library,\n};\n\nexport enum TypeKind {\n    Integer,\n    Float,\n    String,\n    Boolean,\n    Date,\n\n    Class,\n    Array,\n    Alias,\n};\n\nexport enum ReferenceKind {\n    Irrelevant,\n    Pointer,   // Default for most languages for dynamically allocated memory (\"Type*\" in C++).\n    Reference, // \"Type&\" in C++\n    Instance,  // \"Type\" as such and default for all value types.\n}\n\n// The root type interface. Used for typed symbols and type aliases.\nexport interface Type {\n    name: string;\n\n    // The super type of this type or empty if this is a fundamental type.\n    // Also used as the target type for type aliases.\n    baseTypes: Type[];\n    kind: TypeKind;\n    reference: ReferenceKind;\n};\n\nexport interface SymbolTableOptions {\n    allowDuplicateSymbols?: boolean;\n}\n\n// A single class for all fundamental types. They are distinguished via the kind field.\nexport class FundamentalType implements Type {\n    public name: string;\n\n    public get baseTypes(): Type[] { return []; }\n    public get kind(): TypeKind { return this.typeKind; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public static readonly integerType: FundamentalType = new FundamentalType(\"int\", TypeKind.Integer, ReferenceKind.Instance);\n    public static readonly floatType: FundamentalType = new FundamentalType(\"float\", TypeKind.Float, ReferenceKind.Instance);\n    public static readonly stringType: FundamentalType = new FundamentalType(\"string\", TypeKind.String, ReferenceKind.Instance);\n    public static readonly boolType: FundamentalType = new FundamentalType(\"bool\", TypeKind.Boolean, ReferenceKind.Instance);\n    public static readonly dateType: FundamentalType = new FundamentalType(\"date\", TypeKind.Date, ReferenceKind.Instance);\n\n    constructor(name: string, typeKind: TypeKind, referenceKind: ReferenceKind) {\n        this.name = name;\n        this.typeKind = typeKind;\n        this.referenceKind = referenceKind;\n    }\n\n    private typeKind: TypeKind;\n    private referenceKind: ReferenceKind;\n}\n\n// The root of the symbol table class hierarchy: a symbol can be any manageable entity (like a block), not only\n// things like variables or classes.\n// We are using a class hierarchy here, instead of an enum or similar, to allow for easy extension and certain\n// symbols can so provide additional APIs for simpler access to their sub elements, if needed.\nexport class Symbol {\n    public name: string = \"\"; // The name of the scope or empty if anonymous.\n    public context: ParseTree | undefined; // Reference to the parse tree which contains this symbol.\n\n    constructor(name: string = \"\") {\n        this.name = name;\n    }\n\n    /**\n     * The parent is usually a scoped symbol as only those can have children, but we allow\n     * any symbol here for special scenarios.\n     * This is rather an internal method and should rarely be used by external code.\n     */\n    public setParent(parent: Symbol | undefined) {\n        this._parent = parent;\n    }\n\n    public get parent(): Symbol | undefined {\n        return this._parent;\n    }\n\n    public get firstSibling(): Symbol {\n        if (this._parent instanceof ScopedSymbol) {\n            return this._parent.firstChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the symbol before this symbol in its scope.\n     */\n    public get previousSibling(): Symbol | undefined {\n        if (!(this._parent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        let result = this._parent.previousSiblingOf(this);\n        if (result) {\n            return result;\n        }\n    }\n\n    /**\n     * Returns the symbol following this symbol in its scope.\n     */\n    public get nextSibling(): Symbol | undefined {\n        if (!(this._parent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        let result = this._parent.nextSiblingOf(this);\n        if (result) {\n            return result;\n        }\n    }\n\n    public get lastSibling(): Symbol {\n        if (this._parent instanceof ScopedSymbol) {\n            return this._parent.lastChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the next symbol in definition order, regardless of the scope.\n     */\n    public get next(): Symbol | undefined {\n        if (this.parent instanceof ScopedSymbol) {\n            return this.parent.nextOf(this);\n        }\n    }\n\n    public removeFromParent() {\n        if (this._parent instanceof ScopedSymbol) {\n            this._parent.removeSymbol(this);\n            this._parent = undefined;\n        }\n    }\n\n    /**\n     * Returns the first symbol with a given name, in the order of appearance in this scope\n     * or any of the parent scopes (conditionally).\n     */\n    public resolve(name: string, localOnly = false): Symbol | undefined {\n        if (this._parent instanceof ScopedSymbol) {\n            return this._parent.resolve(name, localOnly);\n        }\n    }\n\n    /**\n     * Get the outermost entity (below the symbol table) that holds us.\n     */\n    public get root(): Symbol | undefined {\n        let run = this._parent;\n        while (run) {\n            if (!run._parent || (run._parent instanceof SymbolTable))\n                return run;\n            run = run._parent;\n        }\n        return run;\n    }\n\n    /**\n     * Returns the symbol table we belong too or undefined if we are not yet assigned.\n     */\n    public get symbolTable(): SymbolTable | undefined {\n        if (this instanceof SymbolTable) {\n            return this;\n        }\n\n        let run = this._parent;\n        while (run) {\n            if (run instanceof SymbolTable)\n                return run;\n            run = run._parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns the next enclosing parent of the given type.\n     */\n    public getParentOfType<T extends Symbol>(t: new (...args: any[]) => T): T | undefined {\n        let run = this._parent;\n        while (run) {\n            if (run instanceof t)\n                return <T>run;\n            run = run._parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * The list of symbols from this one up to root.\n     */\n    public get symbolPath(): Symbol[] {\n        let result: Symbol[] = [];\n        let run: Symbol = this;\n        while (run) {\n            result.push(run);\n            if (!run._parent)\n                break;\n            run = run._parent;\n        }\n        return result;\n    }\n\n    /**\n     * Creates a qualified identifier from this symbol and its parent.\n     * If `full` is true then all parents are traversed in addition to this instance.\n     */\n    public qualifiedName(separator = \".\", full = false, includeAnonymous = false): string {\n        if (!includeAnonymous && this.name.length == 0)\n            return \"\";\n\n        let result: string = this.name.length == 0 ? \"<anonymous>\" : this.name;\n        let run = this._parent;\n        while (run) {\n            if (includeAnonymous || run.name.length > 0) {\n                result = (run.name.length == 0 ? \"<anonymous>\" : run.name) + separator + result;\n                if (!full || !run._parent)\n                    break;\n            }\n            run = run._parent;\n        }\n        return result;\n    }\n\n    protected _parent: Symbol | undefined;\n};\n\n// A symbol with an attached type (variables, fields etc.).\nexport class TypedSymbol extends Symbol {\n    public type: Type | undefined;\n\n    constructor(name: string, type?: Type) {\n        super(name);\n        this.type = type;\n    }\n};\n\n// An alias for another type.\nexport class TypeAlias extends Symbol implements Type {\n    public get baseTypes(): Type[] { return [this.targetType]; }\n    public get kind(): TypeKind { return TypeKind.Alias; }\n    public get reference(): ReferenceKind { return ReferenceKind.Irrelevant; }\n\n    constructor(name: string, target: Type) {\n        super(name);\n        this.targetType = target;\n    }\n\n    private targetType: Type;\n};\n\n// A symbol with a scope (so it can have child symbols).\nexport class ScopedSymbol extends Symbol {\n    constructor(name = \"\") {\n        super(name)\n    }\n\n    public get children() {\n        return this._children;\n    }\n\n    public clear() {\n        this._children = [];\n    }\n\n    /**\n     * Adds the given symbol to this scope. If it belongs already to a different scope\n     * it is removed from that before adding it here.\n     */\n    public addSymbol(symbol: Symbol) {\n        symbol.removeFromParent();\n\n        // Check for duplicates first.\n        let symbolTable = this.symbolTable;\n        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {\n            for (let child of this._children) {\n                if (child == symbol || (symbol.name.length > 0 && child.name == symbol.name)) {\n                    let name = symbol.name;\n                    if (name.length == 0)\n                        name = \"<anonymous>\";\n                    throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + name + \"'\");\n                }\n            }\n        }\n\n        this._children.push(symbol);\n        symbol.setParent(this);\n    }\n\n    public removeSymbol(symbol: Symbol) {\n        let index = this._children.indexOf(symbol);\n        if (index > -1) {\n            this._children.splice(index, 1);\n            symbol.setParent(undefined);\n        }\n    }\n\n    /**\n     * Returns all (nested) children of a given type.\n     */\n    public getNestedSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        let result: T[] = [];\n\n        for (let child of this._children) {\n            if (child instanceof t)\n                result.push(child);\n            if (child instanceof ScopedSymbol)\n                result.push(...child.getNestedSymbolsOfType(t));\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns symbols from this and all nested scopes in the order they were defined.\n     * @param name If given only returns symbols with that name.\n     */\n    public getAllNestedSymbols(name?: string): Symbol[] {\n        let result: Symbol[] = [];\n\n        for (let child of this._children) {\n            if (!name || child.name == name) {\n                result.push(child);\n            }\n            if (child instanceof ScopedSymbol)\n                result.push(...child.getAllNestedSymbols(name));\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns direct children of a given type.\n     */\n    public getSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        let result: T[] = [];\n        for (let child of this._children) {\n            if (child instanceof t)\n                result.push(<T>child);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns all symbols of the the given type, accessible from this scope (if localOnly is false),\n     * within the owning symbol table.\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     */\n    public getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): Set<Symbol> {\n        let result: Set<Symbol> = new Set();\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (let child of this._children) {\n            if (child instanceof t) {\n                result.add(child);\n            }\n            if (child instanceof NamespaceSymbol) {\n                child.getAllSymbols(t, true).forEach(result.add, result);\n            }\n        }\n\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol) {\n                this._parent.getAllSymbols(t, true).forEach(result.add, result);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the first symbol with a given name, in the order of appearance in this scope\n     * or any of the parent scopes (conditionally).\n     */\n    public resolve(name: string, localOnly = false): Symbol | undefined {\n        for (let child of this._children) {\n            if (child.name == name)\n                return child;\n        }\n\n        // Nothing found locally. Let the parent continue.\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol)\n                return this._parent.resolve(name, false);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Returns all accessible symbols that have a type assigned.\n     */\n    public getTypedSymbols(localOnly = true): TypedSymbol[] {\n        let result: TypedSymbol[] = []\n\n        for (let child of this._children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child);\n            }\n        }\n\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol) {\n                let localList = (this._parent as ScopedSymbol).getTypedSymbols(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * The names of all accessible symbols with a type.\n     */\n    public getTypedSymbolNames(localOnly = true): string[] {\n        let result: string[] = [];\n        for (let child of this._children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child.name);\n            }\n        }\n\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol) {\n                let localList = (this._parent as ScopedSymbol).getTypedSymbolNames(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns all direct child symbols with a scope (e.g. classes in a module).\n     */\n    public get directScopes(): ScopedSymbol[] {\n        return this.getSymbolsOfType(ScopedSymbol);\n    }\n\n    /**\n     * Returns the symbol located at the given path through the symbol hierarchy.\n     * @param path The path consisting of symbol names separator by `separator`.\n     * @param separator The character to separate path segments.\n     */\n    public symbolFromPath(path: string, separator: string = \".\"): Symbol | undefined {\n        let elements = path.split(separator);\n        let index = 0;\n        if (elements[0] == this.name || elements[0].length == 0)\n            ++index;\n\n        let result: Symbol = this;\n        while (index < elements.length) {\n            if (!(result instanceof ScopedSymbol)) // Some parts left but found a non-scoped symbol?\n                return undefined;\n\n            let child = result._children.find(child => child.name == elements[index]);\n            if (!child)\n                return undefined;\n            result = child;\n            ++index;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given child symbol in the child list or -1 if it couldn't be found.\n     */\n    public indexOfChild(child: Symbol): number {\n        return this._children.findIndex((value: Symbol, index: number) => {\n            return value == child;\n        });\n    }\n\n    /**\n     * Returns the sibling symbol after the given child symbol, if one exists.\n     */\n    public nextSiblingOf(child: Symbol): Symbol | undefined {\n        let index = this.indexOfChild(child);\n        if (index == -1 || index >= this._children.length - 1) {\n            return;\n        }\n        return this._children[index + 1];\n    }\n\n    /**\n     * Returns the sibling symbol before the given child symbol, if one exists.\n     */\n    public previousSiblingOf(child: Symbol): Symbol | undefined {\n        let index = this.indexOfChild(child);\n        if (index < 1) {\n            return;\n        }\n        return this._children[index - 1];\n    }\n\n    public get firstChild(): Symbol | undefined {\n        if (this._children.length > 0) {\n            return this._children[0];\n        }\n    }\n\n    public get lastChild(): Symbol | undefined {\n        if (this._children.length > 0) {\n            return this._children[this._children.length - 1];\n        }\n    }\n\n    /**\n     * Returns the next symbol in definition order, regardless of the scope.\n     */\n    public nextOf(child: Symbol): Symbol | undefined {\n        if (!(child.parent instanceof ScopedSymbol)) {\n            return;\n        }\n        if (child.parent != this) {\n            return child.parent.nextOf(child);\n        }\n\n        if (child instanceof ScopedSymbol && child.children.length > 0) {\n            return child.children[0];\n        }\n\n        let sibling = this.nextSiblingOf(child);\n        if (sibling) {\n            return sibling;\n        }\n\n        return (this.parent as ScopedSymbol).nextOf(this);\n    }\n\n    private _children: Symbol[] = []; // All child symbols in definition order.\n};\n\nexport class NamespaceSymbol extends ScopedSymbol {\n}\n\nexport class BlockSymbol extends ScopedSymbol {\n}\n\nexport class VariableSymbol extends TypedSymbol {\n    constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n        this.value = value;\n    }\n\n    value: any;\n};\n\nexport class LiteralSymbol extends TypedSymbol {\n    constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n        this.value = value;\n    }\n\n    readonly value: any;\n};\n\nexport class ParameterSymbol extends VariableSymbol { };\n\n// A standalone function/procedure/rule.\nexport class RoutineSymbol extends ScopedSymbol {\n    returnType: Type | undefined; // Can be null if result is void.\n\n    constructor(name: string, returnType: Type) {\n        super(name);\n        this.returnType = returnType;\n    }\n\n    public getVariables(localOnly = true): VariableSymbol[] {\n        return this.getSymbolsOfType(VariableSymbol);\n    }\n\n    public getParameters(localOnly = true): ParameterSymbol[] {\n        return this.getSymbolsOfType(ParameterSymbol);\n    }\n};\n\nexport enum MethodFlags {\n    None = 0,\n    Virtual = 1,\n    Const = 2,\n    Overwritten = 4,\n    SetterOrGetter = 8, // Distinguished by the return type.\n    Explicit = 16,      // Special flag used e.g. in C++ for explicit c-tors.\n};\n\n// A routine which belongs to a class or other outer container structure.\nexport class MethodSymbol extends RoutineSymbol {\n    public methodFlags = MethodFlags.None;\n    public visibility = MemberVisibility.Invalid;\n\n    constructor(name: string, returnType: Type) {\n        super(name, returnType);\n    }\n};\n\nexport class FieldSymbol extends VariableSymbol {\n    public visibility = MemberVisibility.Invalid;\n\n    public setter: MethodSymbol | undefined;\n    public getter: MethodSymbol | undefined;\n\n    constructor(name: string, type: Type) {\n        super(name, type);\n    }\n};\n\n// Classes and structs.\nexport class ClassSymbol extends ScopedSymbol implements Type {\n\n    public get baseTypes(): Type[] { return this.superClasses; };\n    public get kind(): TypeKind { return TypeKind.Class; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public isStruct = false;\n\n    /**\n     * Usually only one member, unless the language supports multiple inheritance.\n     */\n    public readonly superClasses: ClassSymbol[] = [];\n\n    constructor(name: string, referenceKind: ReferenceKind, ...superClass: ClassSymbol[]) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.superClasses.push(...superClass); // Standard case: a single super class.\n    }\n\n    /**\n     * Returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): MethodSymbol[] {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * Returns all fields.\n     */\n    public getFields(includeInherited = false): FieldSymbol[] {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n\n    private referenceKind: ReferenceKind;\n};\n\nexport class ArrayType extends Symbol implements Type {\n\n    public get baseTypes(): Type[] { return []; };\n    public get kind(): TypeKind { return TypeKind.Array; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public readonly elementType: Type;\n    public readonly size: number; // > 0 if fixed length.\n\n    constructor(name: string, referenceKind: ReferenceKind, elemType: Type, size = 0) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.elementType = elemType;\n        this.size = size;\n    }\n\n    private referenceKind: ReferenceKind;\n};\n\n// The main class managing all the symbols for a top level entity like a file, library or similar.\nexport class SymbolTable extends ScopedSymbol {\n    constructor(name: string, public readonly options: SymbolTableOptions) {\n        super(name);\n    }\n\n    public clear() {\n        super.clear();\n        this.dependencies.clear();\n    }\n\n    public addDependencies(...tables: SymbolTable[]) {\n        tables.forEach((value, key) => {\n            this.dependencies.add(value);\n        });\n    }\n\n    public removeDependency(table: SymbolTable) {\n        if (this.dependencies.has(table)) {\n            this.dependencies.delete(table);\n        }\n    }\n\n    /**\n     * Returns instance informations, mostly relevant for unit testing.\n     */\n    public get info() {\n        return {\n            dependencyCount: this.dependencies.size,\n            symbolCount: this.children.length\n        };\n    }\n\n    public addNewSymbolOfType<T extends Symbol>(t: new (...args: any[]) => T,\n        parent: ScopedSymbol | undefined, ...args: any[]): T {\n\n        let result = new t(...args);\n        if (!parent || parent == this) {\n            this.addSymbol(result);\n        } else {\n            parent.addSymbol(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a new namespace to the symbol table or the given parent. The path parameter specifies a single namespace name\n     * or a chain of namespaces (which can be e.g. \"outer.intermittant.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     */\n    public addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string, delimiter = \".\"): NamespaceSymbol {\n        let parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent == undefined) ? this : parent;\n        while (i < parts.length - 1) {\n            let namespace = currentParent.resolve(parts[i], true) as NamespaceSymbol;\n            if (namespace == undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    public getAllSymbols<T extends Symbol>(t?: new (...args: any[]) => T, localOnly: boolean = false): Set<Symbol> {\n        let type = t ? t : Symbol;\n        let result = super.getAllSymbols(type, localOnly);\n\n        if (!localOnly) {\n            for (let dependency of this.dependencies) {\n                dependency.getAllSymbols(t, localOnly).forEach(result.add, result);\n            }\n        }\n\n        return result;\n    }\n\n    public symbolWithContext(context: ParseTree): Symbol | undefined {\n\n        function findRecursive(symbol: Symbol): Symbol | undefined {\n            if (symbol.context == context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (let child of symbol.children) {\n                    let result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        }\n\n        let symbols = this.getAllSymbols(Symbol);\n        for (let symbol of symbols) {\n            let result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (let dependency of this.dependencies) {\n            symbols = dependency.getAllSymbols(Symbol);\n            for (let symbol of symbols) {\n                let result = findRecursive(symbol);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    public resolve(name: string, localOnly = false): Symbol | undefined {\n        let result = super.resolve(name, localOnly);\n\n        if (!result && !localOnly) {\n            for (let dependency of this.dependencies) {\n                result = dependency.resolve(name, false);\n                if (result)\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    // Other symbol information available to this instance.\n    protected dependencies: Set<SymbolTable> = new Set();\n};\n"]}