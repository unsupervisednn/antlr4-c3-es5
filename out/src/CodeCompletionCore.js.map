{"version":3,"file":"CodeCompletionCore.js","sourceRoot":"","sources":["../../src/CodeCompletionCore.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2016, 2017, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n'use strict';\n\nimport { Parser, Vocabulary, Token, TokenStream, RuleContext, ParserRuleContext } from 'antlr4ts';\nimport { ATN, ATNState, ATNStateType, Transition, TransitionType, PredicateTransition, RuleTransition, RuleStartState, PrecedencePredicateTransition } from 'antlr4ts/atn';\nimport { IntervalSet } from 'antlr4ts/misc/IntervalSet';\n\nexport type TokenList = number[];\nexport type RuleList = number[];\n\n// All the candidates which have been found. Tokens and rules are separated (both use a numeric value).\n// Token entries include a list of tokens that directly follow them (see also the \"following\" member in the FollowSetWithPath class).\nexport class CandidatesCollection {\n    public tokens: Map<number, TokenList> = new Map();\n    public rules: Map<number, RuleList> = new Map();\n};\n\n// A record for a follow set along with the path at which this set was found.\n// If there is only a single symbol in the interval set then we also collect and store tokens which follow\n// this symbol directly in its rule (i.e. there is no intermediate rule transition). Only single label transitions\n// are considered. This is useful if you have a chain of tokens which can be suggested as a whole, because there is\n// a fixed sequence in the grammar.\nclass FollowSetWithPath {\n    public intervals: IntervalSet;\n    public path: RuleList = [];\n    public following: TokenList = [];\n};\n\n// A list of follow sets (for a given state number) + all of them combined for quick hit tests.\n// This data is static in nature (because the used ATN states are part of a static struct: the ATN).\n// Hence it can be shared between all C3 instances, however it depends on the actual parser class (type).\nclass FollowSetsHolder {\n    public sets: FollowSetWithPath[];\n    public combined: IntervalSet;\n};\n\ntype FollowSetsPerState = Map<number, FollowSetsHolder>;\n\n// Token stream position info after a rule was processed.\ntype RuleEndStatus = Set<number>;\n\nclass PipelineEntry {\n    state: ATNState;\n    tokenIndex: number;\n};\n\n// The main class for doing the collection process.\nexport class CodeCompletionCore {\n    // Debugging options. Print human readable ATN state and other info.\n    public showResult = false;                 // Not dependent on showDebugOutput. Prints the collected rules + tokens to terminal.\n    public showDebugOutput = false;            // Enables printing ATN state info to terminal.\n    public debugOutputWithTransitions = false; // Only relevant when showDebugOutput is true. Enables transition printing for a state.\n    public showRuleStack = false;              // Also depends on showDebugOutput. Enables call stack printing for each rule recursion.\n\n    // Tailoring of the result.\n    public ignoredTokens: Set<number>;        // Tokens which should not appear in the candidates set.\n    public preferredRules: Set<number>;       // Rules which replace any candidate token they contain.\n                                              // This allows to return descriptive rules (e.g. className, instead of ID/identifier).\n\n    private parser: Parser;\n    private atn: ATN;\n    private vocabulary: Vocabulary;\n    private ruleNames: string[];\n    private tokens: TokenList;\n    private precedenceStack: Array<number>;\n\n    private tokenStartIndex: number = 0;\n    private statesProcessed: number = 0;\n\n    // A mapping of rule index + token stream position to end token positions.\n    // A rule which has been visited before with the same input position will always produce the same output positions.\n    private shortcutMap: Map<number, Map<number, RuleEndStatus>> = new Map();\n    private candidates: CandidatesCollection = new CandidatesCollection(); // The collected candidates (rules and tokens).\n\n    private static followSetsByATN: Map<string, FollowSetsPerState> = new Map();\n\n    constructor(parser: Parser) {\n        this.parser = parser;\n        this.atn = parser.atn;\n        this.vocabulary = parser.vocabulary;\n        this.ruleNames = parser.ruleNames;\n        this.ignoredTokens = new Set();\n        this.preferredRules = new Set();\n    }\n\n    /**\n     * This is the main entry point. The caret token index specifies the token stream index for the token which currently\n     * covers the caret (or any other position you want to get code completion candidates for).\n     * Optionally you can pass in a parser rule context which limits the ATN walk to only that or called rules. This can significantly\n     * speed up the retrieval process but might miss some candidates (if they are outside of the given context).\n     */\n    public collectCandidates(caretTokenIndex: number, context?: ParserRuleContext): CandidatesCollection {\n        this.shortcutMap.clear();\n        this.candidates.rules.clear();\n        this.candidates.tokens.clear();\n        this.statesProcessed = 0;\n        this.precedenceStack = [];\n\n        this.tokenStartIndex = context ? context.start.tokenIndex : 0;\n        let tokenStream: TokenStream = this.parser.inputStream;\n\n        let currentIndex = tokenStream.index;\n        tokenStream.seek(this.tokenStartIndex);\n        this.tokens = [];\n        let offset = 1;\n        while (true) {\n            let token = tokenStream.LT(offset++);\n            this.tokens.push(token.type);\n            if (token.tokenIndex >= caretTokenIndex || token.type == Token.EOF)\n                break;\n        }\n        tokenStream.seek(currentIndex);\n\n        let callStack: number[] = [];\n        let startRule = context ? context.ruleIndex : 0;\n        this.processRule(this.atn.ruleToStartState[startRule], 0, callStack, 0, 0);\n\n        if (this.showResult) {\n            console.log(\"States processed: \" + this.statesProcessed);\n            console.log(\"\\n\\nCollected rules:\\n\");\n            for (let rule of this.candidates.rules) {\n                let path = \"\";\n                for (let token of rule[1]) {\n                    path += this.ruleNames[token] + \" \";\n                }\n                console.log(this.ruleNames[rule[0]] + \", path: \", path);\n            }\n\n            let sortedTokens: Set<string> = new Set();\n            for (let token of this.candidates.tokens) {\n                let value: string = this.vocabulary.getDisplayName(token[0]);\n                for (let following of token[1])\n                    value += \" \" + this.vocabulary.getDisplayName(following);\n                sortedTokens.add(value);\n            }\n\n            console.log(\"\\n\\nCollected tokens:\\n\");\n            for (let symbol of sortedTokens) {\n                console.log(symbol);\n            }\n            console.log(\"\\n\\n\");\n        }\n\n        return this.candidates;\n    }\n\n    /**\n     * Checks if the predicate associated with the given transition evaluates to true.\n     */\n    private checkPredicate(transition: PredicateTransition): boolean {\n        return transition.predicate.eval(this.parser, ParserRuleContext.emptyContext());\n    }\n\n    /**\n     * Walks the rule chain upwards to see if that matches any of the preferred rules.\n     * If found, that rule is added to the collection candidates and true is returned.\n     */\n    private translateToRuleIndex(ruleStack: RuleList): boolean {\n        if (this.preferredRules.size == 0)\n            return false;\n\n        // Loop over the rule stack from highest to lowest rule level. This way we properly handle the higher rule\n        // if it contains a lower one that is also a preferred rule.\n        for (let i = 0; i < ruleStack.length; ++i) {\n            if (this.preferredRules.has(ruleStack[i])) {\n                // Add the rule to our candidates list along with the current rule path,\n                // but only if there isn't already an entry like that.\n                let path = ruleStack.slice(0, i);\n                let addNew = true;\n                for (let rule of this.candidates.rules) {\n                    if (rule[0] != ruleStack[i] || rule[1].length != path.length)\n                        continue;\n                    // Found an entry for this rule. Same path? If so don't add a new (duplicate) entry.\n                    if (path.every((v, j) => v === rule[1][j])) {\n                        addNew = false;\n                        break;\n                    }\n                }\n\n                if (addNew) {\n                    this.candidates.rules.set(ruleStack[i], path);\n                    if (this.showDebugOutput)\n                        console.log(\"=====> collected: \", this.ruleNames[ruleStack[i]]);\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * This method follows the given transition and collects all symbols within the same rule that directly follow it\n     * without intermediate transitions to other rules and only if there is a single symbol for a transition.\n     */\n    private getFollowingTokens(transition: Transition): number[] {\n        let result: number[] = [];\n\n        let seen: ATNState[] = [];\n        let pipeline: ATNState[] = [transition.target];\n\n        while (pipeline.length > 0) {\n            let state = pipeline.pop();\n\n            for (let transition of state!.getTransitions()) {\n                if (transition.serializationType == TransitionType.ATOM) {\n                    if (!transition.isEpsilon) {\n                        let list = transition.label!.toArray();\n                        if (list.length == 1 && !this.ignoredTokens.has(list[0])) {\n                            result.push(list[0]);\n                            pipeline.push(transition.target);\n                        }\n                    } else {\n                        pipeline.push(transition.target);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Entry point for the recursive follow set collection function.\n     */\n    private determineFollowSets(start: ATNState, stop: ATNState): FollowSetWithPath[] {\n        let result: FollowSetWithPath[] = [];\n        let seen: Set<ATNState> = new Set();\n        let ruleStack: number[] = [];\n        this.collectFollowSets(start, stop, result, seen, ruleStack);\n\n        return result;\n    }\n\n    /**\n     * Collects possible tokens which could be matched following the given ATN state. This is essentially the same\n     * algorithm as used in the LL1Analyzer class, but here we consider predicates also and use no parser rule context.\n     */\n    private collectFollowSets(s: ATNState, stopState: ATNState, followSets: FollowSetWithPath[], seen: Set<ATNState>, ruleStack: number[]) {\n\n        if (seen.has(s))\n            return;\n\n        seen.add(s);\n\n        if (s == stopState || s.stateType == ATNStateType.RULE_STOP) {\n            let set = new FollowSetWithPath();\n            set.intervals = IntervalSet.of(Token.EPSILON);\n            set.path = ruleStack.slice();\n            followSets.push(set);\n            return;\n        }\n\n        for (let transition of s.getTransitions()) {\n            if (transition.serializationType == TransitionType.RULE) {\n                let ruleTransition: RuleTransition = transition as RuleTransition;\n                if (ruleStack.indexOf(ruleTransition.target.ruleIndex) != -1)\n                    continue;\n\n                ruleStack.push(ruleTransition.target.ruleIndex);\n                this.collectFollowSets(transition.target, stopState, followSets, seen, ruleStack);\n                ruleStack.pop();\n\n            } else if (transition.serializationType == TransitionType.PREDICATE) {\n                if (this.checkPredicate(transition as PredicateTransition))\n                    this.collectFollowSets(transition.target, stopState, followSets, seen, ruleStack);\n            } else if (transition.isEpsilon) {\n                this.collectFollowSets(transition.target, stopState, followSets, seen, ruleStack);\n            } else if (transition.serializationType == TransitionType.WILDCARD) {\n                let set = new FollowSetWithPath();\n                set.intervals = IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                set.path = ruleStack.slice();\n                followSets.push(set);\n            } else {\n                let label = transition.label;\n                if (label && label.size > 0) {\n                    if (transition.serializationType == TransitionType.NOT_SET) {\n                        label = label.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                    }\n                    let set = new FollowSetWithPath();\n                    set.intervals = label;\n                    set.path = ruleStack.slice();\n                    set.following = this.getFollowingTokens(transition);\n                    followSets.push(set);\n                }\n            }\n        }\n    }\n\n    /**\n     * Walks the ATN for a single rule only. It returns the token stream position for each path that could be matched in this rule.\n     * The result can be empty in case we hit only non-epsilon transitions that didn't match the current input or if we\n     * hit the caret position.\n     */\n    private processRule(startState: RuleStartState, tokenIndex: number, callStack: number[], precedence: number,\n        indentation: number): RuleEndStatus {\n\n        // Start with rule specific handling before going into the ATN walk.\n\n        // Check first if we've taken this path with the same input before.\n        let positionMap = this.shortcutMap.get(startState.ruleIndex);\n        if (!positionMap) {\n            positionMap = new Map();\n            this.shortcutMap.set(startState.ruleIndex, positionMap);\n        } else {\n            if (positionMap.has(tokenIndex)) {\n                if (this.showDebugOutput) {\n                    console.log(\"=====> shortcut\");\n                }\n                return positionMap.get(tokenIndex)!;\n            }\n        }\n\n        let result: RuleEndStatus = new Set<number>();\n\n        // For rule start states we determine and cache the follow set, which gives us 3 advantages:\n        // 1) We can quickly check if a symbol would be matched when we follow that rule. We can so check in advance\n        //    and can save us all the intermediate steps if there is no match.\n        // 2) We'll have all symbols that are collectable already together when we are at the caret when entering a rule.\n        // 3) We get this lookup for free with any 2nd or further visit of the same rule, which often happens\n        //    in non trivial grammars, especially with (recursive) expressions and of course when invoking code completion\n        //    multiple times.\n        let setsPerState = CodeCompletionCore.followSetsByATN.get(this.parser.constructor.name);\n        if (!setsPerState) {\n            setsPerState = new Map();\n            CodeCompletionCore.followSetsByATN.set(this.parser.constructor.name, setsPerState);\n        }\n\n        let followSets = setsPerState.get(startState.stateNumber);\n        if (!followSets) {\n            followSets = new FollowSetsHolder();\n            setsPerState.set(startState.stateNumber, followSets);\n            let stop = this.atn.ruleToStopState[startState.ruleIndex];\n            followSets.sets = this.determineFollowSets(startState, stop);\n\n            // Sets are split by path to allow translating them to preferred rules. But for quick hit tests\n            // it is also useful to have a set with all symbols combined.\n            let combined = new IntervalSet();\n            for (let set of followSets.sets)\n                combined.addAll(set.intervals);\n            followSets.combined = combined;\n        }\n\n        callStack.push(startState.ruleIndex);\n        if (tokenIndex >= this.tokens.length - 1) { // At caret?\n            if (this.preferredRules.has(startState.ruleIndex)) {\n                // No need to go deeper when collecting entries and we reach a rule that we want to collect anyway.\n                this.translateToRuleIndex(callStack);\n            } else {\n                // Convert all follow sets to either single symbols or their associated preferred rule and add\n                // the result to our candidates list.\n                for (let set of followSets.sets) {\n                    let fullPath = callStack.slice();\n                    fullPath.push(...set.path);\n                    if (!this.translateToRuleIndex(fullPath)) {\n                        for (let symbol of set.intervals.toArray())\n                            if (!this.ignoredTokens.has(symbol)) {\n                                if (this.showDebugOutput) {\n                                    console.log(\"=====> collected: \", this.vocabulary.getDisplayName(symbol));\n                                }\n                                if (!this.candidates.tokens.has(symbol))\n                                    this.candidates.tokens.set(symbol, set.following); // Following is empty if there is more than one entry in the set.\n                                else {\n                                    // More than one following list for the same symbol.\n                                    if (this.candidates.tokens.get(symbol) != set.following)\n                                        this.candidates.tokens.set(symbol, []);\n                                }\n                            }\n                    }\n                }\n            }\n\n            callStack.pop();\n            return result;\n\n        } else {\n            // Process the rule if we either could pass it without consuming anything (epsilon transition)\n            // or if the current input symbol will be matched somewhere after this entry point.\n            // Otherwise stop here.\n            let currentSymbol = this.tokens[tokenIndex];\n            if (!followSets.combined.contains(Token.EPSILON) && !followSets.combined.contains(currentSymbol)) {\n                callStack.pop();\n                return result;\n            }\n        }\n\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.push(precedence);\n        }\n\n        // The current state execution pipeline contains all yet-to-be-processed ATN states in this rule.\n        // For each such state we store the token index + a list of rules that lead to it.\n        let statePipeline: PipelineEntry[] = [];\n        let currentEntry;\n\n        // Bootstrap the pipeline.\n        statePipeline.push({ state: startState, tokenIndex: tokenIndex });\n\n        while (statePipeline.length > 0) {\n            currentEntry = statePipeline.pop()!;\n            ++this.statesProcessed;\n\n            let currentSymbol = this.tokens[currentEntry.tokenIndex];\n\n            let atCaret = currentEntry.tokenIndex >= this.tokens.length - 1;\n            if (this.showDebugOutput) {\n                this.printDescription(indentation, currentEntry.state, this.generateBaseDescription(currentEntry.state),\n                    currentEntry.tokenIndex);\n                if (this.showRuleStack)\n                    this.printRuleState(callStack);\n            }\n\n            if (currentEntry.state.stateType == ATNStateType.RULE_STOP) {\n                // Record the token index we are at, to report it to the caller.\n                result.add(currentEntry.tokenIndex);\n                continue;\n            }\n\n            let transitions = currentEntry.state.getTransitions();\n\n            // We simulate here the same precedence handling as the parser does, which uses hard coded values.\n            // For rules that are not left recursive this value is ignored (since there is no precedence transition).\n            for (let transition of transitions) {\n                switch (transition.serializationType) {\n                    case TransitionType.RULE: {\n                        let ruleTransition = transition as RuleTransition;\n                        let endStatus = this.processRule(transition.target as RuleStartState, currentEntry.tokenIndex,\n                            callStack, ruleTransition.precedence, indentation + 1);\n                        for (let position of endStatus) {\n                            statePipeline.push({ state: (<RuleTransition>transition).followState, tokenIndex: position });\n                        }\n                        break;\n                    }\n\n                    case TransitionType.PREDICATE: {\n                        if (this.checkPredicate(transition as PredicateTransition))\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex });\n                        break;\n                    }\n\n                    case TransitionType.PRECEDENCE: {\n                        const predTransition = transition as PrecedencePredicateTransition;\n                        if (predTransition.precedence >= this.precedenceStack[this.precedenceStack.length - 1])\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex });\n\n                        break;\n                    }\n\n                    case TransitionType.WILDCARD: {\n                        if (atCaret) {\n                            if (!this.translateToRuleIndex(callStack)) {\n                                for (let token of IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType).toArray())\n                                    if (!this.ignoredTokens.has(token))\n                                        this.candidates.tokens.set(token, []);\n                            }\n                        } else {\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex + 1 });\n                        }\n                        break;\n                    }\n\n                    default: {\n                        if (transition.isEpsilon) {\n                            // Jump over simple states with a single outgoing epsilon transition.\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex });\n                            continue;\n                        }\n\n                        let set = transition.label;\n                        if (set && set.size > 0) {\n                            if (transition.serializationType == TransitionType.NOT_SET) {\n                                set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                            }\n                            if (atCaret) {\n                                if (!this.translateToRuleIndex(callStack)) {\n                                    let list = set.toArray();\n                                    let addFollowing = list.length == 1;\n                                    for (let symbol of list)\n                                        if (!this.ignoredTokens.has(symbol)) {\n                                            if (this.showDebugOutput)\n                                                console.log(\"=====> collected: \", this.vocabulary.getDisplayName(symbol));\n\n                                            if (addFollowing)\n                                                this.candidates.tokens.set(symbol, this.getFollowingTokens(transition));\n                                            else\n                                                this.candidates.tokens.set(symbol, []);\n                                        }\n                                }\n                            } else {\n                                if (set.contains(currentSymbol)) {\n                                    if (this.showDebugOutput)\n                                        console.log(\"=====> consumed: \", this.vocabulary.getDisplayName(currentSymbol));\n                                    statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex + 1 });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        callStack.pop();\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.pop();\n        }\n\n        // Cache the result, for later lookup to avoid duplicate walks.\n        positionMap.set(tokenIndex, result);\n\n        return result;\n    }\n\n    private atnStateTypeMap: string[] = [\n        \"invalid\",\n        \"basic\",\n        \"rule start\",\n        \"block start\",\n        \"plus block start\",\n        \"star block start\",\n        \"token start\",\n        \"rule stop\",\n        \"block end\",\n        \"star loop back\",\n        \"star loop entry\",\n        \"plus loop back\",\n        \"loop end\"\n    ]\n\n    private generateBaseDescription(state: ATNState): string {\n        let stateValue = state.stateNumber == ATNState.INVALID_STATE_NUMBER ? \"Invalid\" : state.stateNumber;\n        return \"[\" + stateValue + \" \" + this.atnStateTypeMap[state.stateType] + \"] in \" + this.ruleNames[state.ruleIndex];\n    }\n\n    private printDescription(indentation: number, state: ATNState, baseDescription: string, tokenIndex: number) {\n\n        const indent = \"  \".repeat(indentation);\n        let output = indent;\n\n        let transitionDescription = \"\";\n        if (this.debugOutputWithTransitions) {\n            for (let transition of state.getTransitions()) {\n                let labels = \"\";\n                let symbols: number[] = transition.label ? transition.label.toArray() : [];\n                if (symbols.length > 2) {\n                    // Only print start and end symbols to avoid large lists in debug output.\n                    labels = this.vocabulary.getDisplayName(symbols[0]) + \" .. \" + this.vocabulary.getDisplayName(symbols[symbols.length - 1]);\n                } else {\n                    for (let symbol of symbols) {\n                        if (labels.length > 0)\n                            labels += \", \";\n                        labels += this.vocabulary.getDisplayName(symbol);\n                    }\n                }\n                if (labels.length == 0)\n                    labels = \"ε\";\n                transitionDescription += \"\\n\" + indent + \"\\t(\" + labels + \") \" + \"[\" + transition.target.stateNumber + \" \" +\n                    this.atnStateTypeMap[transition.target.stateType] + \"] in \" + this.ruleNames[transition.target.ruleIndex];\n            }\n        }\n\n        if (tokenIndex >= this.tokens.length - 1)\n            output += \"<<\" + this.tokenStartIndex + tokenIndex + \">> \";\n        else\n            output += \"<\" + this.tokenStartIndex + tokenIndex + \"> \";\n        console.log(output + \"Current state: \" + baseDescription + transitionDescription);\n    }\n\n    private printRuleState(stack: number[]) {\n        if (stack.length == 0) {\n            console.log(\"<empty stack>\");\n            return;\n        }\n\n        for (let rule of stack)\n            console.log(this.ruleNames[rule]);\n    }\n\n}\n"]}